type Customer 
    @model
    @auth(rules: [
        { allow: groups, groups: ["Admins"] },
        { allow: private, provider: iam, operations: [read, update] }
    ]) {
        id: ID!
        firstName: String!
        lastName: String!
        active: Boolean!
        address: String!
}

type Product
  @model
  @auth(rules: [
      { allow: groups, groups: ["Admins"] },
      { allow: public, provider: iam, operations: [read] }
  ]) {
      id: ID! @primaryKey
      name: String! @index(name: "productsByName", sortKeyFields: ["added"], queryField: "productsByName")
      description: String!
      price: String!
      active: Boolean!
      added: AWSDateTime!
      orders: [Order] @hasMany
}

# TODO: handle the subscription case when auth is not added - it doesn't create a subscription resolver
type Order @model {
  id: ID! @primaryKey(sortKeyFields: ["productID"])
  productID: ID! 
  total: String!
  ordered: AWSDateTime!
  expirationUnixTime: AWSTimestamp! 
}

type Thread @model {
  forumName: String! 
    @primaryKey(sortKeyFields: ["subject"]) 
    @index(name: "byLatestPost", sortKeyFields: ["latestPostAt"])

  subject:  String!
  latestPostAt: AWSDateTime!
  replies: Int!
}

type Blog @model
  @auth(rules: [{ allow: owner, provider: oidc, identityClaim: "sub" }])
{
  id: ID!
  name: String!
  posts: [Post] @hasMany
}

type Post @model {
  id: ID!
  title: String!
  blog: Blog @belongsTo
  comments: [Comment] @hasMany
}

type Comment @model {
  id: ID!
  content: String
  post: Post @belongsTo
}

# Demonstrate the function resolvers
type User @model(queries: null, mutations: null, subscriptions: null)
    @auth(rules: [
        { allow: groups, groups: ["Admins"] },
        { allow: owner, ownerField: "sub" },
        { allow: private, provider: iam, operations: [create, update] }
    ]) {
    id: ID!
    enabled: Boolean!
    status: String!
    email: String!
    name: String!
    email_verified: String
    phone_number: String
    phone_number_verified: String
}

type UserConnection {
    items: [User]
}

input CreateUserInput {
    email: String!
    name: String!
}

input UpdateUserInput {
    id: ID!
    email: String
    name: String
    number: String
}

# https://jsonplaceholder.typicode.com/
type Todo {
  id: Int!
  userId: Int!
  title: String!
  completed: Boolean!
}

# Demonstrate the function resolvers
type Query {
  listUsers: UserConnection @function(name: "test-function")
  getUser(id: ID!): User @function(name: "test-function")

  listTodos: [Todo] @http(url: "https://jsonplaceholder.typicode.com/todos")
  getTodo: Todo @http(url: "https://jsonplaceholder.typicode.com/todos/:id")
}

type Mutation {
  createUser(input: CreateUserInput!): User @function(name: "test-function")
  updateUser(input: UpdateUserInput!): User @function(name: "test-function")
}
